这几天面试，总结一下面试遇到的问题，查漏补缺

https://segmentfault.com/a/1190000002440502

#### 1.vue生命周期及执行顺序
      beforecreated：实例化vue对象，此时 el 和 data 并未初始化 
      created：对象及其事件完全初始化，即通常初始化某些属性值，完成 data 数据的初始化，此时 el 并没有
      beforeMount：检查是否有任何模板可用于要在DOM中呈现。如果没有找到模板，那么它将所定义元素的外部HTML视为模板，此时完成 el 初始化，但页面模版还未替换
      mounted：完成挂载，将数据放入模板并创建可呈现元素，可以对 DOM 进行一些需要的操作
  data里的值被修改后，将会触发update的操作
      beforeUpdate：更改已完成，但尚未准备好更新DOM
      updated：在 DOM 中呈现更改
      beforeDestroy：Vue对象被破坏并从内存中释放之前
      destroyed：Vue实例对象销毁并从内存中删除，清理它与其它实例的连接，解绑它的全部指令及事件监听器
    
  通常created使用的次数多，调用ajax获取页面初始化所需的数据可以在此执行，而mounted通常是在一些插件的使用或者组件的使用中进行操作，因为这些都需要依赖 DOM 的生成
    
#### 2.vue与react的区别
##### 1.ReactJS的背景和原理
    在Web开发中，我们总需要将变化的数据实时反应到UI上，这时就需要对DOM进行操作。而复杂或频繁的DOM操作通常是性能瓶颈产生的原因（如何进行高性能的复杂DOM操作通常是衡量一个前端开发人员技能的重要指标）。React为此引入了虚拟DOM（Virtual DOM）的机制：在浏览器端用Javascript实现了一套DOM API。基于React进行开发时所有的DOM构造都是通过虚拟DOM进行，每当数据变化时，React都会重新构建整个DOM树，然后React将当前整个DOM树和上一次的DOM树进行对比，得到DOM结构的区别，然后仅仅将需要变化的部分进行实际的浏览器DOM更新。而且React能够批处理虚拟DOM的刷新，在一个事件循环（Event Loop）内的两次数据变化会被合并，例如你连续的先将节点内容从A变成B，然后又从B变成A，React会认为UI不发生任何变化，而如果通过手动控制，这种逻辑通常是极其复杂的。尽管每一次都需要构造完整的虚拟DOM树，但是因为虚拟DOM是内存数据，性能是极高的，而对实际DOM进行操作的仅仅是Diff部分，因而能达到提高性能的目的。这样，在保证性能的同时，开发者将不再需要关注某个数据的变化如何更新到一个或多个具体的DOM元素，而只需要关心在任意一个数据状态下，整个界面是如何Render的。
    如果你像在90年代那样写过服务器端Render的纯Web页面那么应该知道，服务器端所要做的就是根据数据Render出HTML送到浏览器端。如果这时因为用户的一个点击需要改变某个状态文字，那么也是通过刷新整个页面来完成的。服务器端并不需要知道是哪一小段HTML发生了变化，而只需要根据数据刷新整个页面。换句话说，任何UI的变化都是通过整体刷新来完成的。而React将这种开发模式以高性能的方式带到了前端，每做一点界面的更新，你都可以认为刷新了整个页面。至于如何进行局部更新以保证性能，则是React框架要完成的事情。
　　借用Facebook介绍React的视频中聊天应用的例子，当一条新的消息过来时，传统开发的思路如上图，你的开发过程需要知道哪条数据过来了，如何将新的DOM结点添加到当前DOM树上；而基于React的开发思路如下图，你永远只需要关心数据整体，两次数据之间的UI如何变化，则完全交给框架去做。可以看到，使用React大大降低了逻辑复杂性，意味着开发难度降低，可能产生Bug的机会也更少。
  
  参考：https://blog.csdn.net/a1943206465/article/details/60570567
  
在React中，数据的流向是单向的——从父节点传递到子节点，因为组件是简单而且易于把握的，他们只需从父节点获取props渲染即可，如果顶层组件的某个prop改变饿了，React会递归的向下便利整棵组件树，重新渲染所有使用这个属性的组件。

★：解释一下单向绑定和双向绑定
  单向绑定非常简单，就是把Model绑定到View，当我们用JavaScript代码更新Model时，View就会自动更新。如果用户更新了View，Model的数据也自动被更新了，这种情况就是双向绑定。
  什么情况下用户可以更新View呢？填写表单就是一个最直接的例子。当用户填写表单时，View的状态就被更新了，如果此时MVVM框架可以自动更新Model的状态，那就相当于我们把Model和View做了双向绑定，在vue中，通过v-model指令把某个表单元素和Model的某个属性作双向绑定。
  https://www.liaoxuefeng.com/wiki/001434446689867b27157e896e74d51a89c25cc8b43bdb3000/00147574857851718682c42639f466a934ad9d4f485d1f2000
  
★：解释一下单向数据流
  只能从一个方向修改数据，父子组件之间通过 prop 形成了一个单向下行绑定：父级 prop 的更新会向下流动到子组件中，但是反过来则不行。这样会防止从子组件意外改变父级组件的状态，从而导致应用的数据流向难以理解

#### 相同点：
  1.虚拟DOM（改变真实的DOM状态远比改变一个JavaScript对象的花销要大得多）；
  2.组件化；
  3.Props属性（从父组件往子组件传送数据）；
  4.构建工具（可以快速搭建开发环境，React使用Create React App (CRA)，而Vue对应的则是vue-cli）；
  5.配套框架（Vue有vue-router和vuex，React有react-router和react-redux）；
#### 不同点：
  1.Vue使用模板，更接近HTML，而React使用JSX语法；
  2.react和vue都是单向数据流，但是vue有双向数据绑定，react没有；
    vue会在初始化时收集所有的依赖，数据改变view跟着改变，双向绑定直接写个v-model就行了，这是框架原生支持；
    react改变数据需要手动调用setState方法

#### 3.异步回调的解决方案

#### 4.怎么实现一个promise，比如用原生JS封装Ajax
Promise 是异步编程的一种解决方案，用来传递异步操作的消息，有了 Promise 对象，就可以将异步操作以同步操作的流程表达出来。
##### Promise有哪些特点
      1.承诺将来会执行
      2.防止回调地狱
      3.可以进行 then 的链式执行
      4.区分数据请求和数据处理
##### Promise有三种状态
      1.pending：                 等待中
      2.resolved（fullfilled）：  成功
      3.rejected：                失败 
##### Promise语法要求
      1.new Promise 实例，必须要 return
      2.new Promise 时要传入函数，函数有 resolve 和 reject 两个参数
      3.成功时执行 resolve()，失败时执行 reject()
##### then()方法的要求：
      1.接收完成态、错误态的回调方法
      2.可选地支持 progress 事件回调作为第三个方法
      3.只接受 function 对象作为参数
      4.返回Promise对象，以实现链式调用
##### Promise.all语法要求      
以一个Promise对象组成的数组作为参数，当数组中所有的 Promise 对象状态都变成 resolved 或 rejected 的时候，它才会去调用then方法。

##### Promise.race
以一个Promise对象组成的数组作为参数，只要当数组中的其中一个 Promsie 状态变成 resolved 或 rejected 时，就可以调用.then方法了。

##### 封装 get 请求
      function getJSON(url) {
          return new Promise(function (resolve, reject) {
              var XHR = XMLHttpRequest ? new XMLHttpRequest() : new window.ActiveXObject('Microsoft.XMLHTTP');
              XHR.onreadystatechange = function () {
                  if (XHR.readyState == 4) {
                      if ((XHR.status >= 200 && XHR.status < 300) || XHR.status == 304) {
                          try {
                              var response = JSON.parse(XHR.responseText);
                              resolve(response);
                          } catch (e) {
                              reject(e);
                          }
                      } else {
                          reject(new Error("Request was unsuccessful: " + XHR.statusText));
                      }
                  }
              }
              XHR.open('GET', url + '?' + params.join('&'), true);
              XHR.send(null);
          })
      }

      getJSON(url).then(resp => console.log(resp));
##### ES5的Callback改用Promise实现

      1.ES5的Callback
      function loadImg(src, callback, fail) {
          var img = document.createElement('img')
          img.onload = function () {
              callback(img)
          }
          img.onerror = function () {
              fail()
          }
          img.src = src
      }
      var src = 'https://www.baidu.com/img/x.gif'
      loadImg(src, function (img) {
          console.log(img.width)
      }, function () {
          console.log('failed')
      })
☆疑问：为什么上面代码中的 img.src = src 要写在 img.onload 事件后面？
解答：js内部是按顺序逐行执行的，可以认为是同步的，图片加载属于异步操作（在看大图网页时，文字可能会先出，然后图片才加载出来，不会因为图片而阻塞加载），当图片是本地图片或缓存图片，浏览器加载图片非常快，几乎在给 img 赋值 src 的时候，图片就已经加载完成并触发了 onload 事件。而如果为 onload 赋值的语句写在后面，当加载完时 onload 事件还没有绑定，什么都不执行。所以给 src 赋值的语句应该写在 onload 后面，这样就能保证图片加载完成触发 onload。

      2.Promise实现
      function loadImg(src) {
          return new Promise(function (resolve, resolve) {
              var img = document.createElement('img')
              img.onload = function () {
                  resolve(img)
              }
              img.onerror = function () {
                  reject()
              }
              img.src = src
          })
      }

      var src = 'https://www.baidu.com/img/x.gif；

      loadImg(src).then(function (img) {
          console.log(img.width)
      }, function () {
          console.log('failed')
      })
      
#### 5.es6用到哪些新特性
http://caibaojian.com/es6/module.html
#### 6.es6的继承怎么实现  es5的继承方式有哪些
http://caibaojian.com/6-javascript-prototype.html

ES6 的 class 属于一种“语法糖”，所以只是写法更加优雅，更加像面对对象的编程，其思想和 ES5 是一致的。
      
      1.es5中的继承 
      function Point(x, y) {
            this.x = x;
            this.y = y;
      }

      Point.prototype.toString = function() {
            return '(' + this.x + ',' + this.y + ')';
      }
      
      2.es6中的继承
      class Point {
            constructor(x, y) {
                  this.x = x;
                  this.y = y;
            }

            toString() {
                  return '(' + this.x + ',' + this.y + ')';
            }
      }
      
constructor 方法是类的构造函数，是一个默认方法，通过 new 命令创建对象实例时，自动调用该方法。一个类必须有 constructor 方法，如果没有显式定义，一个默认的 consructor 方法会被默认添加。所以即使你没有添加构造函数，也是会有一个默认的构造函数的。一般 constructor 方法返回实例对象 this ，但是也可以指定  constructor 方法返回一个全新的对象，让返回的实例对象不是该类的实例。

super 关键字，既可以当做函数使用，也可以当做对象使用。这两种情况下，它的用法完全不用。

      1.当函数使用，代表父类的构造函数
      class A {}
      
      class B extends A {
            constructor() {
                  super();  // ES6 要求，子类的构造函数必须执行一次 super 函数，否则会报错。
            }
      }
      
如果子类调用constructor，那么子类必须在constructor方法中调用super方法，否则新建实例时会报错。这是因为子类没有自己的this对象，而是继承父类的this对象，然后对其进行加工。如果不调用super方法，子类就得不到this对象
      
☆注意：在 constructor 中必须调用 super 方法，因为子类没有自己的 this 对象，而是继承父类的 this 对象，然后对其进行加工,而 super 就代表了父类的构造函数。super 虽然代表了父类 A 的构造函数，但是返回的是子类 B 的实例，即 super 内部的 this 指的是 B，因此 super() 在这里相当于 A.prototype.constructor.call(this, props)。在 super() 执行时，它指向的是 子类 B 的构造函数，而不是父类 A 的构造函数。也就是说，super() 内部的 this 指向的是 B。

      2.当做对象使用，在普通方法中，指向父类的原型对象；在静态方法中，指向父类
      
在js的类中，方法可以分为三种，constructor构造方法、静态方法与普通方法。

1.constructor构造方法：类的作用在于构建对象，而constructor构造方法就是用于构建对象实例。

2.使用方法

在使用new关键字生成对象时，constructor方法会被执行，最终return的结果就是生成的对象实例。

当一个类没有constructor方法时会自动生成一个空的constructor方法，返回结果为空。

用new关键字实例化对象时传入的参数会做为constructor构造函数的参数传入。

      class Point {
          constructor(name) {
              console.log('Instantiate objects:'+ name);
          }
      }

      new Point('testObj'); //Instantiate objects:testObj

1.普通方法：class类的普通方法可以看作是构造函数的另一种写法，相当于在类的prototype属性上上边定义方法。

      class Point {
          toString() {
              // ...
          }
      }

      //等同于
      class Point {
      }

      Point.prototype={
          toString() {
              // ...
          }
      }
      
2.使用方法

(1).该类实例化的对象上使用此方法

      class Point {
          toString() {
              // ...
          }
      }

      let obj = new Point();
      obj.toString();
      
(2).直接通过该类的prototype调用此方法

      class Point {
          toString() {
              // ...
          }
      }

      Point.prototype.toString();
      
(3).通过子类的__proto__调用

      class Foo {
        commonMethod() {
          return 'hello';
        }
      }

      class Bar extends Foo {
      }

      Bar.__proto__.prototype.commonMethod();
      
1.静态方法：类相当于实例的原型，所有在类中定义的方法，都会被实例继承。如果在一个方法前，加上static关键字，就表示该方法不会被实例继承，而是直接通过类来调用（通过类调用指在该类之外调用），这就称为“静态方法”。

2.使用方法：静态方法只能在当前类上调用，不能被该类的实例对象调用。父类的静态方法可以被子类继承。因此静态方法被调用的方式一共有三种（父类直接调用；子类继承父类后调用；子类通过super对象调用）

      class Foo {
        static classMethod() {
          return 'hello';
        }
      }

      Foo.classMethod();  //hello

      class Bar extends Foo {
      }

      class Cla extends Foo {
          return super.classMethod(); //hello
      }

      Bar.classMethod();  //hello

http://www.cnblogs.com/Wayou/p/es6_new_features.html

#### 7.哪几种形式属于跨域，有哪些解决跨域的方案

#### 8.异步函数写在mounted里边好还是写在beforemounted里边好

#### 9.spa的实现原理，怎么实现一个单页面应用，路由跳转的原理
  答：
    服务端渲染处理来自浏览器的请求时，要根据不同的Url路由，拼接出对应的视图页面，通过Http返回给浏览器进行解析渲染，其响应过程是这样的
      1.浏览器发出请求
      2.服务器监听到80端口（或443）有请求过来，并解析url路径
      3.根据服务器的路由配置，返回相应信息（可以是 html 字串，也可以是 json 数据，图片等）
      4.浏览器根据数据包的Content-Type来决定如何解析数据
    简单来说路由就是用来跟后端服务器进行交互的一种方式，通过不同的路径，来请求不同的资源，请求不同的页面是路由的其中一种功能。随着Ajax的应用，出现了单页应用，单页应用不仅仅是在页面交互是无刷新的，连页面跳转都是无刷新的，为了实现单页应用，所以就有了前端路由。
    前端路由的实现其实很简单，本质上就是检测 url 的变化，截获 url 地址，然后解析来匹配路由规则。在2014年之前，大家是通过 hash 来实现路由，url 后面 hash 值的变化，并不会导致浏览器向服务器发出请求，浏览器不发出请求，也就不会刷新页面。另外每次 hash 值的变化，还会触发 hashchange 这个事件，通过这个事件我们就可以知道 hash 值发生了哪些变化，检测到 hash 的变化后，就可以通过替换 DOM 的方式来实现页面的更换，这种实现相对来说要简单方便些，而且不用服务器来支持。
    HTML5标准发布之后，多了两个 API，pushState 和 replaceState，通过这两个 API 可以改变 url 地址且不会发送请求。同时还有 onpopstate 事件。通过这些就能用另一种方式来实现前端路由了，但原理都是跟 hash 实现相同的。用了 HTML5 的实现，单页路由的 url 就不会多出一个#，变得更加美观。但因为没有 # 号，所以当用户刷新页面之类的操作时，浏览器还是会给服务器发送请求。为了避免出现这种情况，所以这个实现需要服务器的支持，需要把所有路由都重定向到根页面。
    
    参考：https://github.com/hwen/blogSome/issues/2

#### 10.es6中有哪些异步方式，怎么实现async和await

#### 11.单页面开发理念

#### 12.css框架和主流样式框架设计理念

#### 13.如何实现前端工程性能优化

#### 14.css盒模型

盒模型的组成由里向外 content，padding，border，margin。盒模型是有两种标准的，一个是标准模型，一个是IE模型。标准模型中，盒模型的宽高只是内容（content）的宽高，而在IE模型中盒模型的宽高是内容(content)+填充(padding)+边框(border)的总宽高。CSS3 的属性 box-sizing 可以在两种盒模型之间切换。

    /* 标准模型 */
    box-sizing:content-box;
    /*IE模型*/
    box-sizing:border-box;

#### 15.原生js怎么获取元素的宽高

    1.  dom.style.width/height 
    只能取到dom元素内联样式所设置的宽高，即只能获取到行间样式

    2. dom.currentStyle.width/height
    获取页面渲染完成后的结果，不管是哪种方式设置的样式，但这种方式只有IE浏览器支持

    3. window.getComputedStyle(dom).width/height 
    获取渲染完成的结果，兼容更多的浏览器

    4. dom.getBoundingClientRect().width/height
    根据元素在视窗中的绝对位置来获取宽高的

    5.dom.offsetWidth/offsetHeight
    最常用的，也是兼容最好的。

#### 16.关于BFC
BFC是英文拼写为 Block Formatting Context 的缩写，直译为“块级格式化上下文”，它是页面中的一块渲染区域，有一套渲染规则，决定了其子元素如何布局，以及和其他元素之间的关系和作用。

##### BFC的原理
    1.内部的盒子会在垂直方向，一个接一个的放置
    2.每个元素的 margin box 的左边，与包含块 border box 的左边相接触（对于从做往右的格式化，否则相反）
    3.box垂直方向的距离由margin决定，属于同一个bfc的两个相邻box的margin会发生重叠
    4.bfc的区域不会与浮动区域的box重叠
    5.bfc是一个页面上的独立的容器，外面的元素不会影响bfc里的元素，反过来，里面的也不会影响外面的
    6.计算bfc高度的时候，浮动元素也会参与计算
##### 怎么取创建bfc
    1.float属性不为none（脱离文档流）
    2.position为absolute或fixed
    3.display为inline-block,table-cell,table-caption,flex,inine-flex
    4.overflow不为visible
    5.根元素
##### 应用场景
    1.自适应两栏布局
    2.清除内部浮动 
    3.防止垂直margin重叠
    
#### 17.常见的垂直居中的布局
    1.margin: auto 实现绝对定位元素的水平垂直居中，IE7及以下低版本浏览器不兼容
    2.margin 的负间距实现绝对定位元素的水平垂直居中,兼容性比较好，比较常用
    3.通过 transform 的 translate 偏移实现绝对定位元素的水平垂直居中，IE8及以下低版本浏览器不兼容
    4.CSS3 弹性盒模型布局不定宽高实现水平垂直居中，不支持低版本IE6-9浏览器的兼容
    
#### 18.websocket与ajax的区别
    1.本质不同
     Ajax,即异步JavaScript和XML，是一种创建交互式网页应用的网页开发技术
     WebSocket是HTML5一种新的协议，实现了浏览器与服务器全双工通信。其本质是先通过HTTP/HTTPS协议进行握手后创建一个用于交换数据的TCP连接，服务端与客户端通过此TCP连接进行实时通信，兼容Chrom4+，Firfox4+，IE10+，Opera10+，Safari5+
    
    2.生命周期不同。
    ajax是短连接，数据发送和接受完成后就会断开连接
    websocket建立的是长连接，在一个会话中一直保持连接
    
    3.适用范围不同
    ajax前后端非实时数据交互
    websocket一般用于前后端实时数据交互
    
    4.发起人不同
    Ajax技术需要客户端发起请求
    WebSocket服务器和客户端可以相互推送信息
    
    5.用法不同
    ajax：
    $.ajax({
        type:"post",
        url:"http://localhost:8080/target",
        data:"state = yes",
        dataType:"json",
        success:funciont(data){
        }
    });
 
    websocket:
    var monitor = new WebSocket("ws://"+ip+path)
    onOpen()、onMessage()、onClose()

#### 19.双向数据实现原理

#### 20.双向数据实现原理

#### 21.说明require的过程

#### 22.Webpack打包原理，如何实现

#### 23.Js数组都有哪些方法及其作用、用法？哪些返回新的数组？详细说了一下splice()的用法？

#### 24.Js数组去重有哪些办法？

#### 25.说明冒泡排序、插入排序实现的思想、步骤、每趟的结果以及什么是二分查找？

#### 26.DOM操作：获取、增、删、查、改等操作

#### 27.JS交换两个节点如何实现？

#### 28.Cookie和Session是什么，有哪些区别？

#### 29.性能优化有哪些原则措施

#### 30.怎么实现深拷贝

#### 31.数组去重有几种实现方法

#### 32.实现跨域的几种方式
同源策略是浏览器最核心也最基本的安全功能，如果缺少了同源策略，浏览器很容易受到XSS、CSRF等攻击，所谓同源是指"协议+域名+端口"三者相同。

      1.通过 jsonp 跨域
      <script>
            var script = document.createElement('script');
            script.type = 'text/javascript';
            // 传参并指定回调执行函数为onBack
            script.src = 'http://www.....:8080/login?user=admin&callback=onBack';
            document.head.appendChild(script);

            // 回调执行函数
            function onBack(res) {
                alert(JSON.stringify(res));
            }
      </script>
      
      2、document.domain + iframe 跨域，此方案仅限主域相同，子域不同的跨域应用场景
      
      父窗口：(http://www.domain.com/a.html)
      
      <iframe id="iframe" src="http://child.domain.com/b.html"></iframe>
      <script>
            document.domain = 'domain.com';
            var user = 'admin';
      </script>
      
      2.）子窗口：(http://child.domain.com/b.html)

      <script>
            document.domain = 'domain.com';
            // 获取父窗口中变量
            alert('get js data from parent ---> ' + window.parent.user);
      </script>
      
      3、nginx 代理跨域

      4、nodejs 中间件代理跨域

      5、后端在头部信息里面设置安全域名
      
      
#### 33.HTML5的离线储存怎么使用，工作原理？

#### 34.什么是 “use strict”; ? 使用它的好处和坏处分别是什么？

      优点：
      1.消除Javascript语法的一些不严谨之处，减少一些怪异行为
      2.消除代码运行的一些不安全之处，保证代码运行的安全
      3.提高编译器效率，增加运行速度
      4.为未来新版本的Javascript做好铺垫

      缺点：
      严格模式改变了语义，可能会导致没有实现严格模式的浏览器中出现问题或者错误

#### 35.什么是闭包
只有函数内部的子函数才能读取局部变量，闭包简单理解成“定义在一个函数内部的函数”，它能够读取父函数内部变量。

      1）由于闭包会使得函数中的变量都被保存在内存中，内存消耗很大，所以不能滥用闭包，否则会造成网页的性能问题
      2）闭包会在父函数外部，改变父函数内部变量的值

#### 你还有什么要问的？
可以问了一下做什么项目、入职后主要做什么、用到的技术栈、加班情况等等这些。
























