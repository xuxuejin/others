这几天面试，总结一下面试遇到的问题，查漏补缺

### 1.vue生命周期及执行顺序
      beforecreated：实例化vue对象，此时 el 和 data 并未初始化 
      created：对象及其事件完全初始化，即通常初始化某些属性值，完成 data 数据的初始化，此时 el 并没有
      beforeMount：检查是否有任何模板可用于要在DOM中呈现。如果没有找到模板，那么它将所定义元素的外部HTML视为模板，此时完成 el 初始化，但页面模版还未替换
      mounted：完成挂载，将数据放入模板并创建可呈现元素，可以对 DOM 进行一些需要的操作
  data里的值被修改后，将会触发update的操作
      beforeUpdate：更改已完成，但尚未准备好更新DOM
      updated：在 DOM 中呈现更改
      beforeDestroy：Vue对象被破坏并从内存中释放之前
      destroyed：Vue实例对象销毁并从内存中删除，清理它与其它实例的连接，解绑它的全部指令及事件监听器
    
  通常created使用的次数多，调用ajax获取页面初始化所需的数据可以在此执行，而mounted通常是在一些插件的使用或者组件的使用中进行操作，因为这些都需要依赖 DOM 的生成
    
### 2.vue与react的区别
#### 1.ReactJS的背景和原理
    在Web开发中，我们总需要将变化的数据实时反应到UI上，这时就需要对DOM进行操作。而复杂或频繁的DOM操作通常是性能瓶颈产生的原因（如何进行高性能的复杂DOM操作通常是衡量一个前端开发人员技能的重要指标）。React为此引入了虚拟DOM（Virtual DOM）的机制：在浏览器端用Javascript实现了一套DOM API。基于React进行开发时所有的DOM构造都是通过虚拟DOM进行，每当数据变化时，React都会重新构建整个DOM树，然后React将当前整个DOM树和上一次的DOM树进行对比，得到DOM结构的区别，然后仅仅将需要变化的部分进行实际的浏览器DOM更新。而且React能够批处理虚拟DOM的刷新，在一个事件循环（Event Loop）内的两次数据变化会被合并，例如你连续的先将节点内容从A变成B，然后又从B变成A，React会认为UI不发生任何变化，而如果通过手动控制，这种逻辑通常是极其复杂的。尽管每一次都需要构造完整的虚拟DOM树，但是因为虚拟DOM是内存数据，性能是极高的，而对实际DOM进行操作的仅仅是Diff部分，因而能达到提高性能的目的。这样，在保证性能的同时，开发者将不再需要关注某个数据的变化如何更新到一个或多个具体的DOM元素，而只需要关心在任意一个数据状态下，整个界面是如何Render的。
    如果你像在90年代那样写过服务器端Render的纯Web页面那么应该知道，服务器端所要做的就是根据数据Render出HTML送到浏览器端。如果这时因为用户的一个点击需要改变某个状态文字，那么也是通过刷新整个页面来完成的。服务器端并不需要知道是哪一小段HTML发生了变化，而只需要根据数据刷新整个页面。换句话说，任何UI的变化都是通过整体刷新来完成的。而React将这种开发模式以高性能的方式带到了前端，每做一点界面的更新，你都可以认为刷新了整个页面。至于如何进行局部更新以保证性能，则是React框架要完成的事情。
　　借用Facebook介绍React的视频中聊天应用的例子，当一条新的消息过来时，传统开发的思路如上图，你的开发过程需要知道哪条数据过来了，如何将新的DOM结点添加到当前DOM树上；而基于React的开发思路如下图，你永远只需要关心数据整体，两次数据之间的UI如何变化，则完全交给框架去做。可以看到，使用React大大降低了逻辑复杂性，意味着开发难度降低，可能产生Bug的机会也更少。
  
  参考：https://blog.csdn.net/a1943206465/article/details/60570567
  
在React中，数据的流向是单向的——从父节点传递到子节点，因为组件是简单而且易于把握的，他们只需从父节点获取props渲染即可，如果顶层组件的某个prop改变饿了，React会递归的向下便利整棵组件树，重新渲染所有使用这个属性的组件。

★：解释一下单向绑定和双向绑定
  单向绑定非常简单，就是把Model绑定到View，当我们用JavaScript代码更新Model时，View就会自动更新。如果用户更新了View，Model的数据也自动被更新了，这种情况就是双向绑定。
  什么情况下用户可以更新View呢？填写表单就是一个最直接的例子。当用户填写表单时，View的状态就被更新了，如果此时MVVM框架可以自动更新Model的状态，那就相当于我们把Model和View做了双向绑定，在vue中，通过v-model指令把某个表单元素和Model的某个属性作双向绑定。
  https://www.liaoxuefeng.com/wiki/001434446689867b27157e896e74d51a89c25cc8b43bdb3000/00147574857851718682c42639f466a934ad9d4f485d1f2000
  
★：解释一下单向数据流
  只能从一个方向修改数据，父子组件之间通过 prop 形成了一个单向下行绑定：父级 prop 的更新会向下流动到子组件中，但是反过来则不行。这样会防止从子组件意外改变父级组件的状态，从而导致应用的数据流向难以理解

#### 相同点：
  1.虚拟DOM（改变真实的DOM状态远比改变一个JavaScript对象的花销要大得多）；
  2.组件化；
  3.Props属性（从父组件往子组件传送数据）；
  4.构建工具（可以快速搭建开发环境，React使用Create React App (CRA)，而Vue对应的则是vue-cli）；
  5.配套框架（Vue有vue-router和vuex，React有react-router和react-redux）；
#### 不同点：
  1.Vue使用模板，更接近HTML，而React使用JSX语法；
  2.react和vue都是单向数据流，但是vue有双向数据绑定，react没有；
    vue会在初始化时收集所有的依赖，数据改变view跟着改变，双向绑定直接写个v-model就行了，这是框架原生支持；
    react改变数据需要手动调用setState方法

3.异步回调的解决方案
4.怎么实现一个promise，比如引用一个第三方框架，加载成功，怎么then调用
5.es6用到哪些新特性
http://caibaojian.com/es6/module.html
6.es6的继承怎么实现  es5的继承方式有哪些
http://caibaojian.com/6-javascript-prototype.html
7.哪几种形式属于跨域，有哪些解决跨域的方案

8.异步函数写在mounted里边好还是写在beforemounted里边好
### 9.spa的实现原理，怎么实现一个单页面应用，路由跳转的原理
  答：
    服务端渲染处理来自浏览器的请求时，要根据不同的Url路由，拼接出对应的视图页面，通过Http返回给浏览器进行解析渲染，其响应过程是这样的
      1.浏览器发出请求
      2.服务器监听到80端口（或443）有请求过来，并解析url路径
      3.根据服务器的路由配置，返回相应信息（可以是 html 字串，也可以是 json 数据，图片等）
      4.浏览器根据数据包的Content-Type来决定如何解析数据
    简单来说路由就是用来跟后端服务器进行交互的一种方式，通过不同的路径，来请求不同的资源，请求不同的页面是路由的其中一种功能。随着Ajax的应用，出现了单页应用，单页应用不仅仅是在页面交互是无刷新的，连页面跳转都是无刷新的，为了实现单页应用，所以就有了前端路由。
    前端路由的实现其实很简单，本质上就是检测 url 的变化，截获 url 地址，然后解析来匹配路由规则。在2014年之前，大家是通过 hash 来实现路由，url 后面 hash 值的变化，并不会导致浏览器向服务器发出请求，浏览器不发出请求，也就不会刷新页面。另外每次 hash 值的变化，还会触发 hashchange 这个事件，通过这个事件我们就可以知道 hash 值发生了哪些变化，检测到 hash 的变化后，就可以通过替换 DOM 的方式来实现页面的更换，这种实现相对来说要简单方便些，而且不用服务器来支持。
    HTML5标准发布之后，多了两个 API，pushState 和 replaceState，通过这两个 API 可以改变 url 地址且不会发送请求。同时还有 onpopstate 事件。通过这些就能用另一种方式来实现前端路由了，但原理都是跟 hash 实现相同的。用了 HTML5 的实现，单页路由的 url 就不会多出一个#，变得更加美观。但因为没有 # 号，所以当用户刷新页面之类的操作时，浏览器还是会给服务器发送请求。为了避免出现这种情况，所以这个实现需要服务器的支持，需要把所有路由都重定向到根页面。
    
    参考：https://github.com/hwen/blogSome/issues/2

10.es6中有哪些异步方式，怎么实现async和await
11.单页面开发理念
12.css框架和主流样式框架设计理念
13.如何实现前端工程性能优化

14.css盒模型

盒模型的组成由里向外 content，padding，border，margin。盒模型是有两种标准的，一个是标准模型，一个是IE模型。标准模型中，盒模型的宽高只是内容（content）的宽高，而在IE模型中盒模型的宽高是内容(content)+填充(padding)+边框(border)的总宽高。CSS3 的属性 box-sizing 可以在两种盒模型之间切换。

    /* 标准模型 */
    box-sizing:content-box;
    /*IE模型*/
    box-sizing:border-box;

#### 15.原生js怎么获取元素的宽高

    1.  dom.style.width/height 
    只能取到dom元素内联样式所设置的宽高，即只能获取到行间样式

    2. dom.currentStyle.width/height
    获取页面渲染完成后的结果，不管是哪种方式设置的样式，但这种方式只有IE浏览器支持

    3. window.getComputedStyle(dom).width/height 
    获取渲染完成的结果，兼容更多的浏览器

    4. dom.getBoundingClientRect().width/height
    根据元素在视窗中的绝对位置来获取宽高的

    5.dom.offsetWidth/offsetHeight
    最常用的，也是兼容最好的。

#### 16.关于BFC
BFC是英文拼写为 Block Formatting Context 的缩写，直译为“块级格式化上下文”，它是页面中的一块渲染区域，有一套渲染规则，决定了其子元素如何布局，以及和其他元素之间的关系和作用。

##### BFC的原理
    1.内部的盒子会在垂直方向，一个接一个的放置
    2.每个元素的 margin box 的左边，与包含块 border box 的左边相接触（对于从做往右的格式化，否则相反）
    3.box垂直方向的距离由margin决定，属于同一个bfc的两个相邻box的margin会发生重叠
    4.bfc的区域不会与浮动区域的box重叠
    5.bfc是一个页面上的独立的容器，外面的元素不会影响bfc里的元素，反过来，里面的也不会影响外面的
    6.计算bfc高度的时候，浮动元素也会参与计算
##### 怎么取创建bfc
    1.float属性不为none（脱离文档流）
    2.position为absolute或fixed
    3.display为inline-block,table-cell,table-caption,flex,inine-flex
    4.overflow不为visible
    5.根元素
##### 应用场景
    1.自适应两栏布局
    2.清除内部浮动 
    3.防止垂直margin重叠
    
#### 17.常见的垂直居中的布局
    1.margin: auto 实现绝对定位元素的水平垂直居中，IE7及以下低版本浏览器不兼容
    2.margin 的负间距实现绝对定位元素的水平垂直居中,兼容性比较好，比较常用
    3.通过 transform 的 translate 偏移实现绝对定位元素的水平垂直居中，IE8及以下低版本浏览器不兼容
    4.CSS3 弹性盒模型布局不定宽高实现水平垂直居中，不支持低版本IE6-9浏览器的兼容
    
#### 18.websocket与ajax的区别
    1.本质不同
     Ajax,即异步JavaScript和XML，是一种创建交互式网页应用的网页开发技术
     WebSocket是HTML5一种新的协议，实现了浏览器与服务器全双工通信。其本质是先通过HTTP/HTTPS协议进行握手后创建一个用于交换数据的TCP连接，服务端与客户端通过此TCP连接进行实时通信，兼容Chrom4+，Firfox4+，IE10+，Opera10+，Safari5+
    
    2.生命周期不同。
    ajax是短连接，数据发送和接受完成后就会断开连接
    websocket建立的是长连接，在一个会话中一直保持连接
    
    3.适用范围不同
    ajax前后端非实时数据交互
    websocket一般用于前后端实时数据交互
    
    4.发起人不同
    Ajax技术需要客户端发起请求
    WebSocket服务器和客户端可以相互推送信息
    
    5.用法不同
    ajax：
    $.ajax({
        type:"post",
        url:"http://localhost:8080/target",
        data:"state = yes",
        dataType:"json",
        success:funciont(data){
        }
    });
 
    websocket:
    var monitor = new WebSocket("ws://"+ip+path)
    onOpen()、onMessage()、onClose()

#### 19.双向数据实现原理

#### 20.双向数据实现原理

#### 21.说明require的过程

#### 22.Webpack打包原理，如何实现

#### 23.Js数组都有哪些方法及其作用、用法？哪些返回新的数组？详细说了一下splice()的用法？

#### 24.Js数组去重有哪些办法？

#### 25.说明冒泡排序、插入排序实现的思想、步骤、每趟的结果以及什么是二分查找？

#### 26.DOM操作：获取、增、删、查、改等操作

#### 27.JS交换两个节点如何实现？

#### 28.Cookie和Session是什么，有哪些区别？

#### 29.性能优化有哪些原则措施

#### 你还有什么要问的？
可以问了一下做什么项目、入职后主要做什么、用到的技术栈、加班情况等等这些。
























