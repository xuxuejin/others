一般情况下局部变量和对象使用完就会被系统自动回收，无需我们理会，但是碰到闭包的情况这些变量和对象是不会被回收的，对于普通的web站点，页面刷新或跳转这些内存也会被回收。如果是单页web站点，页面切换及数据请求都是通过ajax无刷新机制实现的，页面资源无法自动回收，时间长了会严重影响性能，造成内存泄漏甚至页面崩溃直接退出，这时候手动释放不用资源就非常必要了，包含删除dom、释放对象等，因此理解js内存释放就显得十分必要了。

### 1.堆内存:
    定义对象或函数,存储的是引用数据类型。首先都会开一个堆内存且有一个引用地址,如果有变量知道了这个引用地址,我们就说该堆内存被占用了,不能被销毁
### 2.堆内存释放或销毁:
    把所有知道该引用地址的变量赋值null,即没人知道该引用地址,浏览器就会在空闲的时候销毁它,也叫垃圾回收
### 3.栈内存（可以理解为作用域）:
    有两种类别,全局作用域和私有作用域，存储基本数据类型，为js代码提供执行环境
### 4.全局作用域的栈内存:
    页面关闭的时候才会销毁
### 5.私有作用域的栈内存(只有函数执行的时候才有私有作用域):
    a.一般情况:函数执行会形成一个新的私有作用域,当私有作用域的代码执行完之后,栈内存会自动销毁和释放
    b.特殊情况:私有作用域的部分内存被其他作用域知道了,那么该栈内存就属于被占用,不会被销毁,常见的两种情况:
#### 5.1.函数执行返回一个引用类型的值,且在别的作用域被接收了,该栈内存不会被销毁
#### 5.2.私有作用域中,给DOM元素的事件绑定方法,该栈内存不会被销毁

## 内存溢出
指的是程序向系统申请一定大小内存，而系统不能满足程序的要求就是内存的溢出。
## 内存泄漏
指申请的内存一直得不到释放，GC回收不了。JavaScript中最常用的垃圾收集方式是标记清除(mark-and-sweep)。当变量进入环境（例如，在函数中声明一个变量）时，就将这个变量标记为“进入环境”。从逻辑上讲，永远不能释放进入环境的变量所占的内存，因为只要执行流进入相应的环境，就可能用到它们。而当变量离开环境时，这将其 标记为“离开环境”。虽然JavaScript 会自动垃圾收集，但是如果我们的代码写法不当，会让变量一直处于“进入环境”的状态，无法被回收。

### 1.全局变量引起的内存泄漏
    function leaks(){  
        leak = 'xxxxxx';
    }
    全局变量在页面关闭的时候才会销毁，因此 leaks 函数执行完毕，leak作为一个全局变量并不会被回收
    
### 2.闭包引起的内存泄漏
    var leaks = (function(){  
        var leak = 'xxxxxx';// 被闭包所引用，不会被回收
        return function(){
            console.log(leak);
        }
    })()
    
    最外层的自执行函数内部的局部变量 leak，在函数执行完成之后，leak本该会被回收，但是它被新的作用域引用，所以不会被回收
    
## 栈（stack）和堆（heap）
stack为自动分配的内存空间，它由系统自动释放；
heap是动态分配的内存，大小不定也不会自动释放；

## js中数据类型分为：基本类型和引用类型
基本类型：Number，String，Boolean，Null，Undefined
引用类型：Object，Arrary，Function...
基本类型的数据是存放在栈区，函数调用时传递的是变量的值；引用类型数据存放在堆区，引用（数据在内存中的地址）存放在栈区，函数调用时传递的是对象的引用（地址）。所以，基本类型与引用类型最大的区别实际就是传值与传址的区别。

## 工具介绍
