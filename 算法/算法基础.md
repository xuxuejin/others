## 算法时间复杂度

## 大O表示法
一个用来表示算法时间复杂度的公式名称，用于指出该算法的效率有多快，在计算机领域用函数O(n)来表示，其中n表示要执行的次数。

### 常见的时间复杂度量级有：

  常数阶O(1)

  对数阶O(logN)

  线性阶O(n)

  线性对数阶O(nlogN)

  平方阶O(n²)

  立方阶O(n³)

  K次方阶O(n^k)

  指数阶(2^n)

上面从上至下依次的时间复杂度越来越大，执行的效率越来越低。

## 常数阶O(1)
无论代码执行了多少行，只要是没有循环等复杂结构，那这个代码的时间复杂度就都是O(1)，如：
    
    int i = 1;
    int j = 2;
    ++i;
    j++;
    int m = i + j;
    
上述代码在执行的时候，它消耗的时候并不随着某个变量的增长而增长，那么无论这类代码有多长，即使有几万几十万行，都可以用O(1)来表示它的时间复杂度。

## 线性阶O(n)

    for(i=1; i<=n; ++i) {
      j = i;
      j++;
    }

这段代码，for循环里面的代码会执行n遍，因此它消耗的时间是随着n的变化而变化的，因此这类代码都可以用O(n)来表示它的时间复杂度。

## 对数阶O(logN)

    int i = 1;
    while(i<n) {
      i = i * 2;
    }
    
从上面代码可以看到，在while循环里面，每次都将 i 乘以 2，乘完之后，i 距离 n 就越来越近了。我们试着求解一下，假设循环x次之后，i 就大于 2 了，此时这个循环就退出了，也就是说 2 的 x 次方等于 n，那么 x = log2^n，也就是说当循环 log2^n 次以后，这个代码就结束了。因此这个代码的时间复杂度为：O(logn)

## 线性对数阶O(nlogN)
线性对数阶O(nlogN) 其实非常容易理解，将时间复杂度为O(logn)的代码循环N遍的话，那么它的时间复杂度就是 n * O(logN)，也就是了O(nlogN)。就拿上面的代码加一点修改来举例：

    for(m=1; m<n; m++) {
      i = 1;
      while(i<n) {
        i = i * 2;
      }
    }
    
## 平方阶O(n²)
平方阶O(n²) 就更容易理解了，如果把 O(n) 的代码再嵌套循环一遍，它的时间复杂度就是 O(n²) 了，举例：

    for(x=1; i<=n; x++) {
      for(i=1; i<=n; i++) {
        j = i;
        j++;
      }
    }
    
这段代码其实就是嵌套了2层n循环，它的时间复杂度就是 O(n * n)，即 O(n²)，如果将其中一层循环的 n 改成 m：

    for(x=1; i<=m; x++) {
      for(i=1; i<=n; i++) {
        j = i;
        j++;
      }
    }
    
那它的时间复杂度就变成了 O(m*n)

## 立方阶O(n³)、K次方阶O(n^k)
参考上面的O(n²) 去理解就好了，O(n³)相当于三层n循环，其它的类似。

## 指数阶(2^n)
如果一个算法的运行时间是指数阶，一般它很难在实践中使用，即使这样的算法通常是对问题的直接求解。当N=20时，运行时间是1000000；如果增长到原来的两倍时，运行时间将是原时间的平方！

## 空间复杂度
既然时间复杂度不是用来计算程序具体耗时的，那么我也应该明白，空间复杂度也不是用来计算程序实际占用的空间的。空间复杂度是对一个算法在运行过程中临时占用存储空间大小的一个量度，同样反映的是一个趋势，我们用 S(n) 来定义。

### 空间复杂度比较常用的有
O(1)、O(n)、O(n²)

## 空间复杂度 O(1)
如果算法执行所需要的临时空间不随着某个变量n的大小而变化，即此算法空间复杂度为一个常量，可表示为 O(1)，举例：

    int i = 1;
    int j = 2;
    ++i;
    j++;
    int m = i + j;
    
代码中的 i、j、m 所分配的空间都不随着处理数据量变化，因此它的空间复杂度 S(n) = O(1)

## 空间复杂度 O(n)

    int[] m = new int[n]
    for(i=1; i<=n; ++i) {
      j = i;
      j++;
    }
    
这段代码中，第一行new了一个数组出来，这个数据占用的大小为n，这段代码虽然有循环，但没有再分配新的空间，因此，这段代码的空间复杂度主要看第一行即可，即 S(n) = O(n)


参考：https://www.imooc.com/article/263501





